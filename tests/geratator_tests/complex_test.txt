open class GeometricPrimitive{

    constructor()
    
    override fun toString(): String {
        return "Figure()"
    }
}

open class AreaPrimitive : GeometricPrimitive{

    protected var area:Int = 0;
    
    constructor()
    
    open fun constructPrimitive(area:Int):Unit{
        this.area = area;
    }
    
    open fun area(): Int{
        return area;
    }

    open fun scale(scale:Int):Unit {
        area = area * scale * scale;
    }
    
    open fun compare(other:AreaPrimitive):Int {
        if (area > other.area){
            return 1
        }
        else if (area < other.area) {
            return -1
        }
        return 0
    }
    
    override fun toString(): String {
        return "AreaPrimitive(area=$area)"
    }
    
}

class Square:AreaPrimitive {

    private var size:Int = 0;
        
    constructor()
    
    fun size():Int{
        return size;
    }
    
    fun size(newSize:Int):Unit{
        size = newSize;
    }
    
    override fun constructPrimitive(size:Int):Unit {
        super.area = size * size;
        this.size = size;        
    }
    
    fun compare(other:Square):Int{
        if (size > other.size){
            return 1;
        } else if (size < other.size){
            return -1;
        }        
        return 0;
    }

    override fun toString(): String {
        return "Square(size=$size)"
    }

}

class Rectangle:AreaPrimitive{
    
    private var length:Int = 0;
    
    private var width: Int = 0;
    
    constructor()

    fun constructPrimitive(length:Int, width:Int):Unit{
        super.area = length * width;
        this.length = length;
        this.width = width;
    }

    override fun toString(): String {
        return "Rectangle(length=$length, width=$width)"
    }

    override fun scale(scale: Int):Unit {
        super.scale(scale)
        this.length = length * scale;
        this.width = width * scale;
    }
}

fun sortInAscendingOrder(primitives: Array<AreaPrimitive>):Unit{
    if (primitives.size < 2)
        return

    val size:Int = primitives.size
    var i:Int = 0
    while(i < size){
        var j:Int = i + 1
        var currentMinIndex:Int = i;
        while (j < size){
            if (primitives[j].compare(primitives[currentMinIndex]) < 0)
                currentMinIndex = j
            j = j + 1
        }
        var tmp:AreaPrimitive = primitives[i]
        primitives[i] = primitives[currentMinIndex]
        primitives[currentMinIndex] = tmp
        i = i + 1
    }
}

fun sortInAscendingOrder(numbers: Array<Int>):Unit{
    if (numbers.size < 2)
        return
    
    val size:Int = numbers.size
    var i:Int = 0
    while(i < size){
        var j:Int = i + 1
        var currentMinIndex:Int = i;
        while (j < size){
            if (numbers[j] < numbers[currentMinIndex])
                currentMinIndex = j
            j = j + 1
        }
        var tmp:Int = numbers[i]
        numbers[i] = numbers[currentMinIndex]
        numbers[currentMinIndex] = tmp
        i = i + 1
    }
}

fun changeSquare(square:Square, newSize:Int):Unit{
    square.size(newSize)
}



fun main():Unit{
    var tmp:AreaPrimitive = Square()
    tmp.constructPrimitive(3)
    var areaPrimitives:Array<AreaPrimitive> = arrayOf(tmp)
    var i:Int = 2
    while (i >= 0){
        tmp = Square()
        tmp.constructPrimitive(i)
        areaPrimitives = areaPrimitives +  tmp
        i = i - 1
    }

    var tmpR:Rectangle = Rectangle()
    tmpR.constructPrimitive(1,2)
    areaPrimitives = areaPrimitives + tmpR

    sortInAscendingOrder(areaPrimitives)

    i = 0
    while (i < areaPrimitives.size){
        print(areaPrimitives[i])
        print("\n")
        i = i + 1
    }

    var nums:Array<Int> = arrayOf(4,2,3,1)
    sortInAscendingOrder(nums)

    i = 0
    while(i < nums.size){
        print(nums[i].toString())
        print("\n")
        i = i + 1
    }

    print("End\n")
}