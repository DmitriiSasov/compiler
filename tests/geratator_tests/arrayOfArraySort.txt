open class GeometricPrimitive{

    constructor()
    
    override fun toString(): String {
        return "Figure()"
    }
}

open class AreaPrimitive : GeometricPrimitive{

    protected var area:Int = 0;
    
    constructor()
    
    open fun constructPrimitive(area:Int):Unit{
        this.area = area;
    }
    
    open fun area(): Int{
        return area;
    }

    open fun scale(scale:Int):Unit {
        area = area * scale * scale;
    }
    
    open fun compare(other:AreaPrimitive):Int {
        if (area > other.area){
            return 1
        }
        else if (area < other.area) {
            return -1
        }
        return 0
    }
    
    override fun toString(): String {
        return "AreaPrimitive(area=$area)"
    }
    
}

class Square:AreaPrimitive {

    private var size:Int = 0;
        
    constructor()
    
    fun size():Int{
        return size;
    }
    
    fun size(newSize:Int):Unit{
        size = newSize;
    }
    
    override fun constructPrimitive(size:Int):Unit {
        super.area = size * size;
        this.size = size;        
    }
    
    fun compare(other:Square):Int{
        if (size > other.size){
            return 1;
        } else if (size < other.size){
            return -1;
        }        
        return 0;
    }

    override fun toString(): String {
        return "Square(size=$size)"
    }

}

class Rectangle:AreaPrimitive{
    
    private var length:Int = 0;
    
    private var width: Int = 0;
    
    constructor()

    fun constructPrimitive(length:Int, width:Int):Unit{
        super.area = length * width;
        this.length = length;
        this.width = width;
    }

    override fun toString(): String {
        return "Rectangle(length=$length, width=$width)"
    }

    override fun scale(scale: Int):Unit {
        super.scale(scale)
        this.length = length * scale;
        this.width = width * scale;
    }
}



fun sort(primitives: Array<AreaPrimitive>, isIncrease:Boolean):Unit{
    if (primitives.size < 2)
        return

    val size:Int = primitives.size
    var i:Int = 0
    while(i < size){
        var j:Int = i + 1
        var currentMinIndex:Int = i;
        while (j < size){
            if (isIncrease){
                if (primitives[j].compare(primitives[currentMinIndex]) < 0) {
                    currentMinIndex = j
                }
            } else {
                if (primitives[j].compare(primitives[currentMinIndex]) > 0) {
                    currentMinIndex = j
                }
            }
            j = j + 1
        }
        var tmp:AreaPrimitive = primitives[i]
        primitives[i] = primitives[currentMinIndex]
        primitives[currentMinIndex] = tmp
        i = i + 1
    }
}

fun sort(arr:Array<Int>, isIncrease:Boolean):Unit {
    var i:Int = 0
    var arrSize:Int = arr.size
    while(i < arrSize){
        var j:Int = i
        var currentMinIndex:Int = j
        while (j < arrSize){
            if (isIncrease){
                if (arr[j] < arr[currentMinIndex]) {
                    currentMinIndex = j
                }
            } else {
                if (arr[j] > arr[currentMinIndex]) {
                    currentMinIndex = j
                }
            }
            j = j + 1
        }
        var tmp:Int = arr[i]
        arr[i] = arr[currentMinIndex]
        arr[currentMinIndex] = tmp
        i = i + 1
    }
}

fun sort(arr:Array<Array<Int>>, isIncrease:Boolean):Unit {
    var i:Int = 0
    var arrSize:Int = arr.size
    while(i < arrSize){
        var j:Int = i
        var currentMinIndex:Int = j
        while (j < arrSize){
            sort(arr[j], isIncrease)
            if (isIncrease){
                if (arr[j].size < arr[currentMinIndex].size) {
                    currentMinIndex = j
                }
            } else {
                if (arr[j].size > arr[currentMinIndex].size) {
                    currentMinIndex = j
                }
            }
            j = j + 1
        }
        var tmp:Array<Int> = arr[i]
        arr[i] = arr[currentMinIndex]
        arr[currentMinIndex] = tmp
        i = i + 1
    }
}

fun changeSquare(square:Square, newSize:Int):Unit{
    square.size(newSize)
}

fun sort(arr:Array<Array<AreaPrimitive>>, isIncrease:Boolean):Unit {
    var i:Int = 0
    var arrSize:Int = arr.size
    while(i < arrSize){
        var j:Int = i
        var currentMinIndex:Int = j
        while (j < arrSize){
            sort(arr[j], isIncrease)
            if (isIncrease){
                if (arr[j].size < arr[currentMinIndex].size) {
                    currentMinIndex = j
                }
            } else {
                if (arr[j].size > arr[currentMinIndex].size) {
                    currentMinIndex = j
                }
            }
            j = j + 1
        }
        var tmp:Array<AreaPrimitive> = arr[i]
        arr[i] = arr[currentMinIndex]
        arr[currentMinIndex] = tmp
        i = i + 1
    }
}

fun main():Unit{
    var tmpS:Square = Square()
    tmpS.constructPrimitive(3)
    var tmp:AreaPrimitive = tmpS
    var areaPrimitives1:Array<AreaPrimitive> = arrayOf(tmp)
    var i:Int = 2   
    while (i >= 0){
        tmpS = Square()
        tmpS.constructPrimitive(i)
        tmp = tmpS
	tmp.scale(i + 1)
        areaPrimitives1 = areaPrimitives1 +  tmp
        i = i - 1
    }

    var tmpR:Rectangle = Rectangle()
    tmpR.constructPrimitive(1,2)
    tmp = tmpR
    var areaPrimitives2:Array<AreaPrimitive> = arrayOf(tmp)
    i = 3
    while (i >= 0){
        tmpR = Rectangle()
        tmpR.constructPrimitive(i, i + 1)
        tmp = tmpR
	tmp.scale(i + 1)
        areaPrimitives2 = areaPrimitives2 +  tmp
        i = i - 1
    }
    var arrayOfAreaPrimitives:Array<Array<AreaPrimitive>> = arrayOf(areaPrimitives1, areaPrimitives2)

    i = 0
    while (i < arrayOfAreaPrimitives.size){
        var j:Int = 0
        while (j < arrayOfAreaPrimitives[i].size){
            print(arrayOfAreaPrimitives[i][j])
            print("\n")
            j = j + 1
        }
        i = i + 1
    }

    sort(arrayOfAreaPrimitives, false)

    i = 0
    while (i < arrayOfAreaPrimitives.size){
        var j:Int = 0
        while (j < arrayOfAreaPrimitives[i].size){
            print(arrayOfAreaPrimitives[i][j])
            print("\n")
            j = j + 1
        }
        i = i + 1
    }
    
}